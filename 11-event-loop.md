## Event Loop
Это отдельный механизм Javascript environment (в Браузере он свой, в Node.js он свой), который обеспечивает асинхронное выполнение кода и 
обработку 
событий.

Он работает с:
1. `Call Stack` (Стек вызовов): Это структура данных, которая отслеживает, в какой функции сейчас выполняется код. Когда функция 
   вызывается, она добавляется в верхнюю часть стека, а когда завершает свою работе – удаляется из него.
2. `Web APIs`: В браузере существуют встроенные API такие, как `setTimeout()`, `fetch()`, `addEventListener()`, и когда какое-то из них 
   вызывается, то оно передаётся в **WebAPI** для обработки.
3. `Callback Queue` (Очередь обратных вызовов): После того, как **WebAPI** завершило _обработку_ асинхронной операции, связанной с 
   определённым событием (например: завершение **Таймера**, или выполнение HTTP-запроса), то соответствующий обработчик этого события 
   помещается в очередь обратных вызовов (`Callback queue`) для его дальнейшего выполнения.  
4. `Event Loop`: Этот механизм следит за `Call Stack` и `Callback Queue`. Если `Call Stack` пуст, то `EventLoop` берёт первое событие из 
   очереди `Callback queue` и добавляет его в `Call Stack` для выполнения.

Пример:  
```js
console.log('Start');

setTimeout(() => {
  console.log('Timeout');
}, 0);

Promise.resolve().then(() => {
  console.log('Promise');
});

console.log('End');

// Start
// End
// Promise
// Timeout
```
Однако, стоит обратить внимание на порядок выполнения `setTimeout` и обработки `Promise`, который зависит от того, как быстро выполняются 
операции в `Call Stack` и какие задачи есть в `Callback Queue`. `Event Loop` обеспечивает асинхронность и контролирует порядок 
выполнения этих задач.
