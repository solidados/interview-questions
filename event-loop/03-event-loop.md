# Event Loop
> Event Loop - это механизм в JavaScript, который обеспечивает асинхронное выполнение кода и управляет порядком выполнения задач в стеке вызовов и очереди событий.

The job of `Event Loop` is to look at teh `Stack`, and look at the `Task Queue`.  
If the `Stack` is empty, it takes the first thing in the `Task Queue` and pushes it into the `Stack`.

Принцип работы следующий:  
1. получаем задачу и выполняем её
2. очищаем поток
3. получаем следующую задачу, выполняем её
4. очищаем поток
5. получаем асинхронную задачу
6. регистрируем её, и ожидаем, когда она выполнится, при этом задача не попадает в основной поток до тех пор, пока не завершит все свои 
   асинхронные действия.
7. пока асинхронная задача выполняет свои действия: делает запрос и получает ответ, ожидает времени выполнения, и так далее, – основной 
   поток пуст и в него попадают задачи, требующие немедленного выполнения.

> `Evennt Loop` – это бесконечный цикл, который ожидает задачи, выполняет их, и затем снова ожидает поступления новых задач.

## Call Stack (Стек Вызовов)
Операции всегда попадают на вершину _стека_ и с этой же вершины они выполняются. 

Простейший случай, когда все операции _синхронные_:
```javascript
function firstFun() {
  console.log('log1')
  console.log('log2')
}

function secondFun() {
  console.log('log3')
  firstFun()
}

secondFun()

// В стек попадают по очереди:
// 1. secondFun()
// 2. log3 выполняется и уходит из стека
// 3. firstFun()
// 4. log1 выполняется и уходит из стека
// 5. log2 выполняется и уходит из стека
// 6. firstFun() возвращает результат и уходит из стека
// 7. secondFun() возвращает результат и уходит из стека
```

Теперь усложним немного задачу, и добавим две синхронные операции `setTimeout()` и `addEventListener('click, cb)`:
```javascript
console.log('start')
const btn = document.querySelector('#btn');

function someFoo() {
  setTimeout(() => {
    console.log('Внутри TimeOut')
  }, 3000)
  
  console.log('Внтури someFoo')
}

btn.addEventListener('click', someFoo)

someFoo()

console.log('end')
```
Здесь, помимо `Call Stack` добавляется `Web API`, которая и предоставляет такие функции, как `setTimeout` и `eventListeners`, и появляется 
`Callback Queue` (очередь задач, или `Task Queue`).

Посмотрим, как это работает:
1. `start` выполняется и уходит из стека
2. получение кнопки `document.querySelector('#btn')` выполняется и уходит из стека
3. регистрируется `btn.addEventListener('click', someFoo)` и попадает в `WebAPI`
4. в `Call Stack` попадает и начинает выполнение `someFoo()`
5. `EventLoop` получает `setTimeout`, регистрирует и отправляет его в `WebAPI`, сразу же запускается счётчик времени, но код при этом код 
   продолжает выполняться.
6. `Внтури someFoo` выполняется и уходит из стека
7. `someFoo()` выполняется и уходит из стека
8. `end` выполняется, но...
9. но при этом, пользователь нажимает на кнопку, а `Call Stack` ещё не пустой, и функция, которая должна выполниться при нажатии на 
 кнопку, попадает в очередь задач (`Callback Queue`), и находится там до тех пор, пока `Call Stack` не станет пустым. Сколько бы задач там 
 ни было, задачи из `Callback Queue` ждут опустошения `Call Stack`.
 10. в этот же момент заканчивается `Timer`, и его callback так же попадает в `Callback Queue` (очередь задач).
11. из `Callback Queue` уходит первым тот, кто в эту очередь попал. 
> И так, задачи ждут своей очереди, а их очередь настанет тогда, когда 
    Стек вызовов очистится.
12. `end` уходит из `Call Stack` и сразу же забирается первый из очереди задач и попадает в Стек вызовов, 
13. и затем всё начинается по кругу.
14. `someFoo()`
15. `console.log('Внутри someFoo()')`
16. `setTimeout()` попадает в WebAPI и запускается счётчик
17. `Стек вызовов` очищается
18. из `очереди` забирается следующая задача и отправляется в `Стек вызовов`

Но в `WebAPI` будет оставаться слушатель события, и пока пользователь не нажмёт на кнопку, `EventLoop` будет ожидать поступления новых 
задач.
